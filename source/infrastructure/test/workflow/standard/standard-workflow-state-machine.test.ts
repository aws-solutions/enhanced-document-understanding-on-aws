/**********************************************************************************************************************
 *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.                                                *
 *                                                                                                                    *
 *  Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance    *
 *  with the License. A copy of the License is located at                                                             *
 *                                                                                                                    *
 *      http://www.apache.org/licenses/LICENSE-2.0                                                                    *
 *                                                                                                                    *
 *  or in the 'license' file accompanying this file. This file is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES *
 *  OR CONDITIONS OF ANY KIND, express or implied. See the License for the specific language governing permissions    *
 *  and limitations under the License.                                                                                *
 *********************************************************************************************************************/

import * as cdk from 'aws-cdk-lib';
import * as lambda from 'aws-cdk-lib/aws-lambda';

import { Capture, Match, Template } from 'aws-cdk-lib/assertions';
import { QueueEncryption, QueueProps } from 'aws-cdk-lib/aws-sqs';
import { StandardWorkflow, StandardWorkflowProps } from '../../../lib/workflow/standard/standard-workflow';

import { StateMachineFragment } from 'aws-cdk-lib/aws-stepfunctions';
import { COMMERCIAL_REGION_LAMBDA_NODE_RUNTIME, WorkflowType } from '../../../lib/utils/constants';

describe('Standard-Workflow SYNC processing task step-function test', () => {
    let workflow: StandardWorkflow;
    let stack: cdk.Stack;
    let template: Template;
    let callbackQueueCapture: Capture;
    let inferenceBucketCapture: Capture;
    let caseTableCapture: Capture;

    beforeAll(async () => {
        const app = new cdk.App();
        stack = new cdk.Stack(app, 'TestStack');

        const workflowProps: StandardWorkflowProps = {
            workflowName: 'SyncTestWorkflow',
            workflowType: WorkflowType.SYNC_ONLY,
            appNamespace: 'fake-namespace',
            orchestratorBusArn: 'arn:fake-partition:fake-service:fake-region:123456789012:fake-eventbus-arn',
            uploadBucketArn: 'arn:fake-partition:fake-service:fake-region:123456789012:fake-s3-arn1',
            inferenceBucketArn: 'arn:fake-partition:fake-service:fake-region:123456789012:fake-s3-arn2',
            caseTableArn: 'arn:fake-partition:dynamodb:fake-region:123456789012:table/fake-table-arn',
            syncLambdaFunctionProps: {
                runtime: COMMERCIAL_REGION_LAMBDA_NODE_RUNTIME,
                handler: 'index.hander',
                code: lambda.Code.fromInline(`exports.handler = async () => {
                    return {
                        output: 'test-output',
                        taskToken: 'fake-task-token'
                    }
                }`)
            },
            genUUID: new cdk.CfnParameter(stack, 'GenUUID', {
                type: 'String',
                description: 'UUID generated in the parent stack that can be used to append to resource logical ids',
                allowedPattern: '^S+$',
                constraintDescription: 'A UUID generated by the custom resource in the parent stack'
            }).valueAsString
        };
        workflow = new StandardWorkflow(stack, 'TestableStandardWorkflowConstruct', workflowProps);
        template = Template.fromStack(stack);
    });

    const sfnRoleCapture = new Capture();

    it('Should create a StateMachine resource', () => {
        const cloudWatchLogGroup = new Capture();
        template.hasResourceProperties('AWS::StepFunctions::StateMachine', {
            DefinitionString: Match.anyValue(),
            LoggingConfiguration: {
                Destinations: [
                    {
                        CloudWatchLogsLogGroup: {
                            LogGroupArn: {
                                'Fn::GetAtt': [cloudWatchLogGroup, 'Arn']
                            }
                        }
                    }
                ],
                Level: 'ERROR'
            },
            RoleArn: {
                'Fn::GetAtt': [sfnRoleCapture, 'Arn']
            },
            TracingConfiguration: {
                Enabled: true
            }
        });

        const jsonTemplate = template.toJSON();
        expect(jsonTemplate['Resources'][cloudWatchLogGroup.asString()]['Type']).toEqual('AWS::Logs::LogGroup');
        expect(jsonTemplate['Resources'][sfnRoleCapture.asString()]['Type']).toEqual('AWS::IAM::Role');
    });

    it('should have a policy for the event bus to call the statemachine', () => {
        const statemachineCapture = new Capture();
        const roleCapture = new Capture();
        template.hasResourceProperties('AWS::IAM::Policy', {
            PolicyDocument: {
                Statement: [
                    {
                        Action: 'states:StartExecution',
                        Effect: 'Allow',
                        Resource: {
                            Ref: statemachineCapture
                        }
                    }
                ],
                Version: '2012-10-17'
            },
            PolicyName: Match.anyValue(),
            Roles: [
                {
                    Ref: roleCapture
                }
            ]
        });

        const jsonTemplate = template.toJSON();
        expect(jsonTemplate['Resources'][statemachineCapture.asString()]['Type']).toEqual(
            'AWS::StepFunctions::StateMachine'
        );
        expect(
            jsonTemplate['Resources'][roleCapture.asString()]['Properties']['AssumeRolePolicyDocument']['Statement'][0][
                'Principal'
            ]['Service']
        ).toEqual('events.amazonaws.com');
    });

    it('Should create a sync lambda with the proper permissions', () => {
        const lambdaRoleCapture = new Capture();
        callbackQueueCapture = new Capture();
        inferenceBucketCapture = new Capture();
        caseTableCapture = new Capture();
        template.resourceCountIs('AWS::Lambda::Function', 1);
        template.hasResourceProperties('AWS::Lambda::Function', {
            Code: {
                ZipFile: `exports.handler = async () => {
                    return {
                        output: 'test-output',
                        taskToken: 'fake-task-token'
                    }
                }`
            },
            Role: {
                'Fn::GetAtt': [lambdaRoleCapture, 'Arn']
            },
            Handler: 'index.hander',
            Runtime: 'nodejs18.x',
            TracingConfig: {
                Mode: 'Active'
            }
        });

        template.hasResourceProperties('AWS::IAM::Policy', {
            PolicyDocument: {
                Statement: [
                    {
                        Action: ['xray:PutTraceSegments', 'xray:PutTelemetryRecords'],
                        Effect: 'Allow',
                        Resource: '*'
                    },
                    {
                        Action: [
                            'sqs:ReceiveMessage',
                            'sqs:ChangeMessageVisibility',
                            'sqs:GetQueueUrl',
                            'sqs:DeleteMessage',
                            'sqs:GetQueueAttributes'
                        ],
                        Effect: 'Allow',
                        Resource: {
                            'Fn::GetAtt': [callbackQueueCapture, 'Arn']
                        }
                    },
                    {
                        Action: [
                            's3:GetObject*',
                            's3:GetBucket*',
                            's3:List*',
                            's3:DeleteObject*',
                            's3:PutObject',
                            's3:PutObjectLegalHold',
                            's3:PutObjectRetention',
                            's3:PutObjectTagging',
                            's3:PutObjectVersionTagging',
                            's3:Abort*'
                        ],
                        Effect: 'Allow',
                        Resource: [inferenceBucketCapture, inferenceBucketCapture]
                    },
                    {
                        Action: [
                            'dynamodb:BatchGetItem',
                            'dynamodb:GetRecords',
                            'dynamodb:GetShardIterator',
                            'dynamodb:Query',
                            'dynamodb:GetItem',
                            'dynamodb:Scan',
                            'dynamodb:ConditionCheckItem',
                            'dynamodb:DescribeTable'
                        ],
                        Effect: 'Allow',
                        Resource: [
                            caseTableCapture,
                            {
                                'Ref': 'AWS::NoValue'
                            }
                        ]
                    },
                    {
                        Action: 'dynamodb:UpdateItem',
                        Effect: 'Allow',
                        Resource: [
                            caseTableCapture,
                            {
                                'Ref': 'AWS::NoValue'
                            }
                        ]
                    }
                ],
                Version: '2012-10-17'
            },
            PolicyName: Match.anyValue(),
            Roles: [
                {
                    Ref: lambdaRoleCapture.asString()
                }
            ]
        });

        expect(inferenceBucketCapture._captured[1]).toEqual(inferenceBucketCapture._captured[0] + '/*');
        expect(caseTableCapture.asString()).toContain('fake-table-arn');
        expect(inferenceBucketCapture.asString()).toContain('fake-s3-arn2');
        expect(caseTableCapture._captured[0]).toEqual(caseTableCapture._captured[1]);
    });

    it('Should create default queueProps', () => {
        const queueProps = workflow.getDefaultQueueProps();
        const expectedProps = {
            queueProps: {
                visibilityTimeout: cdk.Duration.minutes(60),
                encryption: QueueEncryption.KMS_MANAGED
            }
        } as QueueProps;
        expect(queueProps).toEqual(expectedProps);

        template.hasResourceProperties('AWS::SQS::QueuePolicy', {
            PolicyDocument: {
                Statement: [
                    {
                        Action: [
                            'sqs:DeleteMessage',
                            'sqs:ReceiveMessage',
                            'sqs:SendMessage',
                            'sqs:GetQueueAttributes',
                            'sqs:RemovePermission',
                            'sqs:AddPermission',
                            'sqs:SetQueueAttributes'
                        ],
                        Effect: 'Allow',
                        Principal: {
                            AWS: {
                                'Fn::Join': [
                                    '',
                                    [
                                        'arn:',
                                        {
                                            Ref: 'AWS::Partition'
                                        },
                                        ':iam::',
                                        {
                                            Ref: 'AWS::AccountId'
                                        },
                                        ':root'
                                    ]
                                ]
                            }
                        },
                        Resource: {
                            'Fn::GetAtt': [callbackQueueCapture.asString(), 'Arn']
                        },
                        Sid: 'QueueOwnerOnlyAccess'
                    },
                    {
                        Action: 'SQS:*',
                        Condition: {
                            Bool: {
                                'aws:SecureTransport': 'false'
                            }
                        },
                        Effect: 'Deny',
                        Principal: {
                            AWS: '*'
                        },
                        Resource: {
                            'Fn::GetAtt': [callbackQueueCapture.asString(), 'Arn']
                        },
                        'Sid': 'HttpsOnly'
                    }
                ],
                'Version': '2012-10-17'
            },
            Queues: [
                {
                    'Ref': Match.stringLikeRegexp(
                        'TestableStandardWorkflowConstructSyncTestWorkflowStepFunctionCallbackTaskqueue*'
                    )
                }
            ]
        });
    });

    it('Should create default DLQ props', () => {
        const queueProps = workflow.getDefaultDLQProps();

        expect(queueProps).toEqual({
            deadLetterQueueProps: {
                retentionPeriod: cdk.Duration.days(7),
                encryption: QueueEncryption.KMS_MANAGED
            }
        });
    });

    it('Should create default sqs event source props', () => {
        const props = workflow.getDefaultSqsEventSourceProps();

        expect(props).toEqual({
            sqsEventSourceProps: {
                enabled: true,
                batchSize: 1
            }
        });
    });

    it('SqsSendMessage Task should be created correctly', async () => {
        const syncRequestTask = workflow.syncRequestTask as StateMachineFragment;
        const startStateJson = syncRequestTask.startState.toStateJson() as { [key: string]: any };

        expect(startStateJson['ResultPath']).toEqual('$');
        expect(startStateJson['Retry']).toContainEqual(
            expect.objectContaining({
                IntervalSeconds: 3,
                MaxAttempts: 6,
                BackoffRate: 2
            })
        );
    });

    it('Should create the failure fragment correctly', async () => {
        const failureFlow = (workflow.map as any).catches[0]; // hack to access private catches array

        // failure flow catches all errors and adds it to input in error field
        expect(failureFlow.props).toEqual({
            errors: ['States.ALL'],
            resultPath: '$.error'
        });
    });

    it('should create cloudwatch log groups for stepfunctions', () => {
        template.hasResourceProperties('AWS::Logs::LogGroup', {
            'LogGroupName': {
                'Fn::Join': [
                    '',
                    [
                        '/aws/vendedlogs/states/',
                        {
                            'Ref': 'AWS::StackName'
                        },
                        '-StateMachineLogGroup--',
                        {
                            'Ref': 'GenUUID'
                        }
                    ]
                ]
            },
            'RetentionInDays': 731
        });
    });

    afterAll(async () => {
        console.debug('test over');
    });
});
